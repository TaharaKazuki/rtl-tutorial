/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * Swagger Petstore
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  CreatePetsBody,
  Error,
  ListPetsNestedArrayParams,
  ListPetsParams,
  Pet,
  PetsArray,
  PetsNestedArray
} from '.././src/model'



/**
 * @summary List all pets
 */
export const getListPetsUrl = (params?: ListPetsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/pets?${normalizedParams.toString()}` : `/pets`
}

export const listPets = async (params?: ListPetsParams, options?: RequestInit): Promise<PetsArray> => {
  
  const res = await fetch(getListPetsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return data as PetsArray
}



export const getListPetsQueryKey = (params?: ListPetsParams,) => {
    return [`/pets`, ...(params ? [params]: [])] as const;
    }

    
export const getListPetsQueryOptions = <TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(params?: ListPetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPets>>> = ({ signal }) => listPets(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPetsQueryResult = NonNullable<Awaited<ReturnType<typeof listPets>>>
export type ListPetsQueryError = Error


export function useListPets<TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(
 params: undefined |  ListPetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPets>>,
          TError,
          TData
        > , 'initialData'
      >, fetch?: RequestInit}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPets<TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(
 params?: ListPetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPets>>,
          TError,
          TData
        > , 'initialData'
      >, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPets<TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(
 params?: ListPetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all pets
 */

export function useListPets<TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(
 params?: ListPetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPetsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create a pet
 */
export const getCreatePetsUrl = () => {


  return `/pets`
}

export const createPets = async (createPetsBody: CreatePetsBody, options?: RequestInit): Promise<void> => {
  
  const res = await fetch(getCreatePetsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPetsBody,)
  }

  )
  const data = await res.json()

  return data as void
}




export const getCreatePetsMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPets>>, {data: CreatePetsBody}> = (props) => {
          const {data} = props ?? {};

          return  createPets(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePetsMutationResult = NonNullable<Awaited<ReturnType<typeof createPets>>>
    export type CreatePetsMutationBody = CreatePetsBody
    export type CreatePetsMutationError = Error

    /**
 * @summary Create a pet
 */
export const useCreatePets = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof createPets>>,
        TError,
        {data: CreatePetsBody},
        TContext
      > => {

      const mutationOptions = getCreatePetsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary List all pets as nested array
 */
export const getListPetsNestedArrayUrl = (params?: ListPetsNestedArrayParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/pets-nested-array?${normalizedParams.toString()}` : `/pets-nested-array`
}

export const listPetsNestedArray = async (params?: ListPetsNestedArrayParams, options?: RequestInit): Promise<PetsNestedArray> => {
  
  const res = await fetch(getListPetsNestedArrayUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return data as PetsNestedArray
}



export const getListPetsNestedArrayQueryKey = (params?: ListPetsNestedArrayParams,) => {
    return [`/pets-nested-array`, ...(params ? [params]: [])] as const;
    }

    
export const getListPetsNestedArrayQueryOptions = <TData = Awaited<ReturnType<typeof listPetsNestedArray>>, TError = Error>(params?: ListPetsNestedArrayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPetsNestedArray>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPetsNestedArrayQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPetsNestedArray>>> = ({ signal }) => listPetsNestedArray(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPetsNestedArray>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPetsNestedArrayQueryResult = NonNullable<Awaited<ReturnType<typeof listPetsNestedArray>>>
export type ListPetsNestedArrayQueryError = Error


export function useListPetsNestedArray<TData = Awaited<ReturnType<typeof listPetsNestedArray>>, TError = Error>(
 params: undefined |  ListPetsNestedArrayParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPetsNestedArray>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPetsNestedArray>>,
          TError,
          TData
        > , 'initialData'
      >, fetch?: RequestInit}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPetsNestedArray<TData = Awaited<ReturnType<typeof listPetsNestedArray>>, TError = Error>(
 params?: ListPetsNestedArrayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPetsNestedArray>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPetsNestedArray>>,
          TError,
          TData
        > , 'initialData'
      >, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPetsNestedArray<TData = Awaited<ReturnType<typeof listPetsNestedArray>>, TError = Error>(
 params?: ListPetsNestedArrayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPetsNestedArray>>, TError, TData>>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all pets as nested array
 */

export function useListPetsNestedArray<TData = Awaited<ReturnType<typeof listPetsNestedArray>>, TError = Error>(
 params?: ListPetsNestedArrayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPetsNestedArray>>, TError, TData>>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPetsNestedArrayQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Info for a specific pet
 */
export const getShowPetByIdUrl = (petId: string,) => {


  return `/pets/${petId}`
}

export const showPetById = async (petId: string, options?: RequestInit): Promise<Pet> => {
  
  const res = await fetch(getShowPetByIdUrl(petId),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return data as Pet
}



export const getShowPetByIdQueryKey = (petId: string,) => {
    return [`/pets/${petId}`] as const;
    }

    
export const getShowPetByIdQueryOptions = <TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(petId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getShowPetByIdQueryKey(petId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof showPetById>>> = ({ signal }) => showPetById(petId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(petId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ShowPetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof showPetById>>>
export type ShowPetByIdQueryError = Error


export function useShowPetById<TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(
 petId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof showPetById>>,
          TError,
          TData
        > , 'initialData'
      >, fetch?: RequestInit}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useShowPetById<TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(
 petId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof showPetById>>,
          TError,
          TData
        > , 'initialData'
      >, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useShowPetById<TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(
 petId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Info for a specific pet
 */

export function useShowPetById<TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(
 petId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getShowPetByIdQueryOptions(petId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



